#' Make analyte mapping table from formula object
#'
#' The formula object must be given as PCTESTCD ~ EXTRT or, if there are multiple
#' analytes from the same treatment: PCTESTCD1 + PCTESTCD2 ~ EXTRT, etc.
#'
#' The return object is a data frame with one line for each analyte. The ANALYTE
#' field is the PCTESTCD for the respective analyte.
#'
#' @param sdtm A sdtm object.
#' @param f A formula.
#' @importFrom rlang f_rhs
#' @importFrom rlang f_lhs
#' @importFrom rlang is_formula
#'
#' @returns A data frame.
formula_to_mapping <- function(sdtm, f) {
  # input validation
  if (!inherits(sdtm, "sdtm")) {
    stop("sdtm must be an sdtm object")
  }

  if(!rlang::is_formula(f))
    stop(paste0(
      "argument ", as.character(f), " is not a formula!"))

  extrt <- intersect(str_split_1(deparse(f_rhs(f)), " "), treatments(sdtm))
  pctestcd <- intersect(str_split_1(deparse(f_lhs(f)), " "), analytes(sdtm))

  if(length(extrt) == 0)
    stop(paste0("extrt ", as.character(rlang::f_rhs(f)),
                " not found in EX!"))
  if(length(pctestcd) == 0)
    stop(paste0("pctestcd ", as.character(rlang::f_lhs(f)),
                " not found in PC!"))

  out <- data.frame(
    PCTESTCD = pctestcd,
    EXTRT = extrt,
    ANALYTE = pctestcd
  )
  return(out)
}


#' Create analyte mapping table from mapping formulae
#'
#' Creates a mapping between treatments (EXTRT) and analytes (PCTESTCD). Each
#' combination of EXTRT and PCTESTCD must be unique. If duplicate mappings are
#' found, an error will be raised.
#'
#' @param sdtm A sdtm object.
#' @param ... Analyte mappings as formulae.
#'
#' @importFrom rlang is_formula
#' @importFrom dplyr bind_rows
#' @importFrom dplyr distinct
#'
#' @returns A data frame with unique combinations of EXTRT and PCTESTCD.
auto_mapping <- function(sdtm, ...) {
  # input validation
  if (!inherits(sdtm, "sdtm")) {
    stop("sdtm must be an sdtm object")
  }

  mapping = list(...)

  if(length(mapping) != 0) {
    temp <- sapply(mapping, is_formula)
    if(!all(temp) == TRUE)
      stop("mappings must be formulae!")
  }

  # Initialize empty data frame with correct structure
  ex_pc_mapping <- data.frame(
    PCTESTCD = character(0),
    EXTRT = character(0),
    ANALYTE = character(0),
    stringsAsFactors = FALSE
  )

  if(length(mapping) == 0) {
    common <- intersect(analytes(sdtm), treatments(sdtm))
    ex_pc_mapping <- data.frame(
      EXTRT = common,
      PCTESTCD = common,
      ANALYTE = common,
      stringsAsFactors = FALSE
    )
  } else {
    for(i in 1:length(mapping)) {
      f <- mapping[[i]]
      if(rlang::is_formula(f)) {
        ex_pc_mapping <- bind_rows(
          ex_pc_mapping, formula_to_mapping(sdtm, f)
        )
      }
    }
  }

  # Check for duplicate mappings
  duplicates <- ex_pc_mapping %>%
    group_by(EXTRT, PCTESTCD) %>%
    filter(n() > 1) %>%
    distinct(EXTRT, PCTESTCD)

  if (nrow(duplicates) > 0) {
    stop("Duplicate mappings found for the following EXTRT-PCTESTCD combinations:\n",
         paste(sprintf("%s ~ %s", duplicates$EXTRT, duplicates$PCTESTCD),
               collapse = "\n"))
  }

  ex_pc_mapping <- ex_pc_mapping %>%
    mutate(PARENT = PCTESTCD) %>%
    mutate(METABOLITE = PCTESTCD != EXTRT) %>%
    group_by(EXTRT) %>%
    mutate(METABOLITE = row_number() != 1)

  ex_pc_mapping
}



#' Auto-generate nif from sdtm object
#'
#'
#'
#' @inheritParams add_observation
#' @param ... Formulae to define the relationships between PCTESTCD and EXTRT.
#'
#' @returns A nif object
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' @export
#'
#' @examples
#' nif_auto(examplinib_sad, RS2023 ~ EXAMPLINIB)
#' nif_auto(examplinib_sad, RS2023 + RS2023487A ~ EXAMPLINIB)
nif_auto <- function(
    sdtm, ...,
    subject_filter = "!ACTARMCD %in% c('SCRNFAIL', 'NOTTRT')",
    observation_filter = "TRUE",
    duplicates = "resolve",
    duplicate_function = mean,
    keep = NULL,
    silent = NULL) {
  # input validation
  if (!inherits(sdtm, "sdtm")) {
    stop("sdtm must be an sdtm object")
  }

  expected_domains <- c("dm", "vs", "ex", "pc")
  missing_domains <- setdiff(expected_domains, names(sdtm$domains))
  if(length(missing_domains) > 0)
    stop(paste0("Missing domains: ", nice_enumeration(missing_domains)))

  analyte_mapping <- auto_mapping(sdtm, ...)
  if(nrow(analyte_mapping) == 0)
    stop("Analyte mapping could not be autogenerated!")

  out <- new_nif()

  # treatments
  treatments <- distinct(analyte_mapping, EXTRT, ANALYTE)
  for(i in 1:nrow(treatments)) {
    t <- treatments[i,]
    out <- out %>%
      add_administration(
        sdtm, extrt = t$EXTRT, analyte = t$ANALYTE,
        subject_filter = subject_filter,
        silent = silent)
  }

  # observations
  for(i in 1:nrow(analyte_mapping)){
    o <- analyte_mapping[i,]
    out <- out %>%
      add_observation(
        sdtm, "pc", o$PCTESTCD, analyte = o$ANALYTE,
        parent = o$PARENT, metabolite = o$METABOLITE,
        subject_filter = subject_filter,
        observation_filter = observation_filter,
        duplicates = duplicates,
        duplicate_function = duplicate_function,
        keep = keep,
        silent = silent)
  }

  # LB-related baseline covariates
  if("lb" %in% names(sdtm$domains)) {
    lb <- domain(sdtm, "lb")

    # baseline renal function
    if("CREAT" %in% unique(lb$LBTESTCD)) {
      conditional_message("Adding baseline CREAT", silent = silent)
      out <- add_baseline(out, sdtm, "lb", "CREAT")
      if(all(c("BL_CREAT", "AGE", "SEX", "RACE", "WEIGHT") %in% names(out))) {
        out <- add_bl_crcl(out)
        out <- add_bl_renal(out)
        conditional_message(
          "Adding baseling CRCL and renal function class",
          silent = silent)
      }
    }

    # baseline hepatic function
    if(all(c("BILI", "AST") %in% unique(lb$LBTESTCD))) {
      conditional_message("Adding baseline hepatic function", silent = silent)
      out <- add_bl_odwg(out, sdtm)
    }
  }

  return(out)
}













